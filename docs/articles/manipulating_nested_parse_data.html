<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Manipulating the nested Parse Table • styler</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">styler</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/krlmlr/styler">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Manipulating the nested Parse Table</h1>
                        <h4 class="author">Lorenz Walthert</h4>
            
            <h4 class="date">2017-08-17</h4>
          </div>

    
    
<div class="contents">
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"dplyr"</span>)
<span class="kw">library</span>(<span class="st">"purrr"</span>)
pkgload::<span class="kw">load_all</span>()</code></pre></div>
<p>This vignette builds on the vignette “Data Structures” and discusses how to go forward with the nested structure of the parse data. In order to compute the white space information in a nested data structure, we need a recursion. We use a <a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor approach</a> to separate the algorithm (computing white space information) from the object (nested) data structure. The function <code><a href="../reference/create_filler.html">create_filler()</a></code> can then be used to add white space information on every level of nesting within the nested parse data if applied in combination with the visitor. <code>visitor()</code> takes a object to operate on and a list of functions. Each function is applied at the current level of nesting before the next level of nesting is entered.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pre_visit</code></pre></div>
<pre><code>## function(pd_nested, funs) {
##   if (is.null(pd_nested)) return()
##   pd_transformed &lt;- visit_one(pd_nested, funs)
## 
##   pd_transformed$child &lt;- map(pd_transformed$child, pre_visit, funs = funs)
##   pd_transformed
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">visit_one</code></pre></div>
<pre><code>## function(pd_flat, funs) {
##   reduce(funs, function(x, fun) fun(x),
##          .init = pd_flat)
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<p>This comes with two advantages.</p>
<ul>
<li>We don’t need a *_nested() version of every function we want to apply to the parse tables, in particular the rules in R/rules.R</li>
<li>We go through the whole structure only once (instead of every *_nested() function going through it once, which is more efficient in terms of speed.</li>
</ul>
<p><code><a href="../reference/create_filler.html">create_filler()</a></code> was adapted to also initialize indention and lag_newlines.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">create_filler</code></pre></div>
<pre><code>## function(pd_flat) {
## 
##   pd_flat$line3 &lt;- lead(pd_flat$line1, default = tail(pd_flat$line2, 1))
##   pd_flat$col3 &lt;- lead(pd_flat$col1, default = tail(pd_flat$col2, 1) + 1L)
##   pd_flat$newlines &lt;- pd_flat$line3 - pd_flat$line2
##   pd_flat$lag_newlines &lt;- lag(pd_flat$newlines, default = 0)
##   pd_flat$col2_nl &lt;- if_else(pd_flat$newlines &gt; 0L, 0L, pd_flat$col2)
##   pd_flat$spaces &lt;- pd_flat$col3 - pd_flat$col2_nl - 1L
##   pd_flat$multi_line &lt;- ifelse(pd_flat$terminal, FALSE, NA)
## 
##   ret &lt;- pd_flat[, !(names(pd_flat) %in% c("line3", "col3", "col2_nl"))]
## 
## 
##   if (!("indent" %in% names(ret))) {
##     ret$indent &lt;- 0
##   }
## 
##   if (any(ret$spaces &lt; 0L)) {
##     stop("Invalid parse data")
##   }
## 
##   ret
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">code &lt;-<span class="st"> "a &lt;- function(x) { if(x &gt; 1) { 1+1 } else {x} }"</span>
pd_nested &lt;-<span class="st"> </span><span class="kw"><a href="../reference/compute_parse_data_nested.html">compute_parse_data_nested</a></span>(code)
pd_nested_enhanced &lt;-<span class="st"> </span><span class="kw"><a href="../reference/visit.html">pre_visit</a></span>(pd_nested, <span class="kw">c</span>(create_filler))
pd_nested_enhanced</code></pre></div>
<pre><code>## # A tibble: 1 x 19
##   line1  col1 line2  col2    id parent token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1    47    49      0  expr    FALSE            
## # ... with 9 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   internal &lt;lgl&gt;, child &lt;list&gt;, newlines &lt;int&gt;, lag_newlines &lt;dbl&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indent &lt;dbl&gt;</code></pre>
<p>As a next step, we need to find a way to serialize the nested tibble, or in other words, to transform it to its character vector representation. As a starting point, consider the function <code>serialize</code> that was introduced in the vignette “Data Structures”.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">serialize &lt;-<span class="st"> </span>function(x) {
  out &lt;-<span class="st"> </span><span class="kw">Map</span>(
    function(terminal, text, child) {
      if (terminal)
        text
      else
        <span class="kw">serialize</span>(child)
    },
    x$terminal, x$text, x$child
  )
  out
}

<span class="kw">serialize</span>(pd_nested) %&gt;%<span class="st"> </span>unlist</code></pre></div>
<pre><code>##  [1] "a"        "&lt;-"       "function" "("        "x"        ")"       
##  [7] "{"        "if"       "("        "x"        "&gt;"        "1"       
## [13] ")"        "{"        "1"        "+"        "1"        "}"       
## [19] "else"     "{"        "x"        "}"        "}"</code></pre>
<p><code>serialize</code> can be combined with <code>serialize_parse_data_flat</code>. The latter pastes together the column “text” of a flat parse table by taking into account space and line break information, splits the string by line break and returns it.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">serialize_parse_data_flat</code></pre></div>
<pre><code>## function(pd_flat) {
##   pd_flat %&gt;%
##     summarize_(
##       text_ws = ~paste0(
##         text, newlines_and_spaces(newlines, spaces),
##         collapse = "")) %&gt;%
##     .[["text_ws"]] %&gt;%
##     strsplit("\\n", fixed = TRUE) %&gt;%
##     .[[1L]]
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<p>However, things get a bit more complicated, mainly because line break and white space information is not only contained in the terminal tibbles of the nested parse data, but even before, as the following example shows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pd_nested_enhanced$child[[<span class="dv">1</span>]]</code></pre></div>
<pre><code>## # A tibble: 3 x 19
##   line1  col1 line2  col2    id parent       token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;       &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1     1     3     49        expr    FALSE            
## 2     1     3     1     4     2     49 LEFT_ASSIGN     TRUE    &lt;-    &lt;-
## 3     1     6     1    47    48     49        expr    FALSE            
## # ... with 9 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   internal &lt;lgl&gt;, child &lt;list&gt;, newlines &lt;int&gt;, lag_newlines &lt;dbl&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indent &lt;dbl&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pd_nested_enhanced$child[[<span class="dv">1</span>]]$child[[<span class="dv">1</span>]]</code></pre></div>
<pre><code>## # A tibble: 1 x 19
##   line1  col1 line2  col2    id parent  token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;  &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1     1     1      3 SYMBOL     TRUE     a     a
## # ... with 9 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   child &lt;list&gt;, internal &lt;lgl&gt;, newlines &lt;int&gt;, lag_newlines &lt;dbl&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indent &lt;dbl&gt;</code></pre>
<p>After “a” in <code>code</code>, there is a space, but this information is not contained in the tibble where we find the terminal “a”. In general, we must add newlines and spaces values <em>after</em> we computed character vector representation of the expression. In our example: we know that there is a space after the non-terminal “a” by looking at <code>pd_nested_enhanced$child[[1]]</code>. Therefore, we need to add this space to the very last terminal within <code>pd_nested_enhanced$child[[1]]</code> before we collapse everything together.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">serialize_parse_data_nested_helper</code></pre></div>
<pre><code>## function(pd_nested, pass_indent) {
##   out &lt;- pmap(list(pd_nested$terminal, pd_nested$text, pd_nested$child,
##                    pd_nested$spaces, pd_nested$lag_newlines, pd_nested$indent),
##               function(terminal, text, child, spaces, lag_newlines, indent) {
##                 total_indent &lt;- pass_indent + indent
##                 preceding_linebreak &lt;- if_else(lag_newlines &gt; 0, 1, 0)
##                 if (terminal) {
##                   c(add_newlines(lag_newlines),
##                     add_spaces(total_indent * preceding_linebreak),
##                     text,
##                     add_spaces(spaces))
##                 } else {
##                   c(add_newlines(lag_newlines),
##                     add_spaces(total_indent * preceding_linebreak),
##                     serialize_parse_data_nested_helper(child, total_indent),
##                     add_spaces(spaces))
##                 }
##               }
##   )
##   out
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">serialize_parse_data_nested</code></pre></div>
<pre><code>## function(pd_nested) {
##   out &lt;- c(add_newlines(start_on_line(pd_nested) - 1),
##            serialize_parse_data_nested_helper(pd_nested, pass_indent = 0)) %&gt;%
##     unlist() %&gt;%
##     paste0(collapse = "") %&gt;%
##     strsplit("\\n", fixed = TRUE) %&gt;%
##     .[[1L]]
##   out
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<p>Before we are done, we need to add information regarding indention to the parse table. We can add indention after every line break that comes after a round bracket with <code><a href="../reference/update_indention.html">indent_round()</a></code>. And then serialize it.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/visit.html">pre_visit</a></span>(pd_nested, 
               <span class="kw">c</span>(create_filler, 
                 purrr::<span class="kw"><a href="http://www.rdocumentation.org/packages/purrr/topics/partial">partial</a></span>(indent_round, <span class="dt">indent_by =</span> <span class="dv">2</span>)))</code></pre></div>
<pre><code>## # A tibble: 1 x 19
##   line1  col1 line2  col2    id parent token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1    47    49      0  expr    FALSE            
## # ... with 9 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   internal &lt;lgl&gt;, child &lt;list&gt;, newlines &lt;int&gt;, lag_newlines &lt;dbl&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indent &lt;dbl&gt;</code></pre>
<p>We can see how indention works with a more complicated example</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">indented &lt;-<span class="st"> </span><span class="kw">c</span>(
  <span class="st">"call("</span>, 
  <span class="st">"  1,"</span>, 
  <span class="st">"  call2("</span>, 
  <span class="st">"    2, 3,"</span>, 
  <span class="st">"    call3(1, 2, 22),"</span>, 
  <span class="st">"    5"</span>, 
  <span class="st">"  ),"</span>, 
  <span class="st">"  144"</span>,
  <span class="st">")"</span>
)

not_indented &lt;-<span class="st"> </span><span class="kw">trimws</span>(indented)
back_and_forth &lt;-<span class="st"> </span>not_indented %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/compute_parse_data_nested.html">compute_parse_data_nested</a></span>() %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/visit.html">pre_visit</a></span>(<span class="kw">c</span>(create_filler, 
        purrr::<span class="kw"><a href="http://www.rdocumentation.org/packages/purrr/topics/partial">partial</a></span>(indent_round, <span class="dt">indent_by =</span> <span class="dv">2</span>))) %&gt;%
<span class="st">  </span><span class="kw"><a href="../reference/serialize_parse_data_nested.html">serialize_parse_data_nested</a></span>()

<span class="kw">identical</span>(indented, back_and_forth)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Kirill Müller.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
